}
return(gene_df)
}
if(gene_col %in% c("rownames","row.names")){
printer("+ Converting rownames to Gene col...",v=verbose)
gene_df$Gene <- row.names(gene_df)
gene_col <- "Gene"
}
if("Gene_orig" %in% colnames(gene_df)){
printer("+ Removing Gene_orig col...",v=verbose)
gene_df <- dplyr::select(gene_df, -Gene_orig)
}
printer("+ Searching for orthologues...",v=verbose)
taxaID <- taxaID_dict(species=input_species)
taxaID_out <- taxaID_dict(species=output_species)
input_genes <- gene_df[[gene_col]]
orths <- homologene::homologene(genes = input_genes,
inTax = unname(taxaID),
outTax = taxaID_out)
orths <- orths[orths[,1] %in% input_genes,]
orths_key <- setNames(orths[,2], orths[,1])
gene_df <- dplyr::rename(gene_df, Gene_orig=all_of(gene_col))
gene_df$Gene <- orths_key[input_genes]
if(drop_nonhuman_genes){
printer("+ Dropping genes with no human orthologues...",v=verbose)
gene_df <- gene_df[!is.na(gene_df$Gene),]
gene_df <- gene_df[gene_df$Gene!="NA_character_",]
}
if(one_to_one_only){
printer("+ Dropping genes that don't have 1-to-1 gene mappings...",v=verbose)
gene_df <- gene_df[!duplicated(gene_df$Gene_orig),]
gene_df <- gene_df[!duplicated(gene_df$Gene),]
}
if(genes_as_rownames){
if(drop_nonhuman_genes==F){
warning("+ drop_nonhuman_genes must =T in order to set genes_as_rownames=T.")
}else {
printer("+ Setting Gene col as rownames...",v=verbose)
if(one_to_one_only==F) stop("Genes must be unique to be row.names. Try again with`one_to_one_only=T`")
row.names(gene_df) <- gene_df$Gene
}
}
# Report
n_dropped <- length(unique(input_genes))-length(unique(gene_df$Gene))
messager("Genes dropped during inter-species conversion: ",
format(n_dropped,big.mark=","),
" / ",
format(length(unique(input_genes)),big.mark=","),
" (",format(n_dropped/length(unique(input_genes))*100, digits = 4),"%)",
v=verbose)
return(gene_df)
}
orths <- convert_orthologues(gene_df=rowDat,
gene_col="rownames",
input_species=input_species,
drop_nonhuman_genes=T,
one_to_one_only=T,
genes_as_rownames=T,
verbose=verbose)
orths
sce <- exp
sce <- HDF5Array::loadHDF5SummarizedExperiment("../model_celltype_conservation/raw_data/scRNAseq/LaManno2020/LaManno2020.sparse.filtered.sce/")
sce2 <- ingest_data(sce)
worker_cores <- if(is.null(no_cores)) .90 else no_cores
core_allocation <- assign_cores(worker_cores = worker_cores)
# IMPORTANT!: Do NOT parallelize this step. It will interfere with DelayedArray functions.
ctd <- lapply(level_names,function(lvl, .sce=sce){
messager("+ Processsing level = ",lvl,v=verbose)
grouped_means <- DelayedArray_grouped_stats(sce = .sce,
grouping_var = lvl,
stat = "mean",
return_sce = F)
grouped_specificity <- grouped_means / DelayedArray::rowSums(grouped_means)
return(list(mean_exp=grouped_means,
specificity=grouped_specificity))
})
sce$Class <- as.factor(gsub(" ","_",sce$Class))
sce$Age <- as.factor(gsub(" |[.]","_",sce$Age))
sce$Class_Age <- as.factor(paste(sce$Class,sce$Age, sep="."))
sce$Class_Tissue <- as.factor(paste(sce$Class, gsub(" ","_",sce$Tissue), sep="."))
sce$Class_Tissue_Age <- as.factor(paste(sce$Class, gsub(" ","_",sce$Tissue), sce$Age, sep="."))
level1="Class"
level2=level2annot="Class_Age"#"Subclass"
level3="Class_Tissue"
level4="Class_Tissue_Age"
annotLevels <- c(level1, level2, level3, level4)
if(length(annotLevels[[1]])>1){
level_names <- names(annotLevels)
}else {
level_names <- annotLevels
}
if(any(!level_names %in% colnames(SummarizedExperiment::colData(sce))) ){
stop("+ When exp is of class 'SingleCellExperiment'",
" all names(annotLevels) must be in the column names of exp@colData.")
}
# IMPORTANT!: Do NOT parallelize this step. It will interfere with DelayedArray functions.
ctd <- lapply(level_names,function(lvl, .sce=sce){
messager("+ Processsing level = ",lvl,v=verbose)
grouped_means <- DelayedArray_grouped_stats(sce = .sce,
grouping_var = lvl,
stat = "mean",
return_sce = F)
grouped_specificity <- grouped_means / DelayedArray::rowSums(grouped_means)
return(list(mean_exp=grouped_means,
specificity=grouped_specificity))
})
rowDat <- SummarizedExperiment::rowData(sce)
orths <- convert_orthologues(gene_df=rowDat,
gene_col="rownames",
input_species=input_species,
drop_nonhuman_genes=T,
one_to_one_only=T,
genes_as_rownames=T,
verbose=verbose)
# Not always sure about how the sce has been named (original species gene names or human orthologues)
sce <- tryCatch({sce[orths$Gene_orig,]},
error=function(e){ sce[orths$Gene,]
})
sce
sce <- check_sce_rownames(sce, rownames_var = "Gene")
rowDat <- SummarizedExperiment::rowData(sce)
orths <- convert_orthologues(gene_df=rowDat,
gene_col="rownames",
input_species=input_species,
drop_nonhuman_genes=T,
one_to_one_only=T,
genes_as_rownames=T,
verbose=verbose)
# Not always sure about how the sce has been named (original species gene names or human orthologues)
sce <- tryCatch({sce[orths$Gene_orig,]},
error=function(e){ sce[orths$Gene,]
})
sce
if(length(annotLevels[[1]])>1){
level_names <- names(annotLevels)
}else {
level_names <- annotLevels
}
if(any(!level_names %in% colnames(SummarizedExperiment::colData(sce))) ){
stop("+ When exp is of class 'SingleCellExperiment'",
" all names(annotLevels) must be in the column names of exp@colData.")
}
worker_cores <- if(is.null(no_cores)) .90 else no_cores
core_allocation <- assign_cores(worker_cores = worker_cores)
# IMPORTANT!: Do NOT parallelize this step. It will interfere with DelayedArray functions.
ctd <- lapply(level_names,function(lvl, .sce=sce){
messager("+ Processsing level = ",lvl,v=verbose)
grouped_means <- DelayedArray_grouped_stats(sce = .sce,
grouping_var = lvl,
stat = "mean",
return_sce = F)
grouped_specificity <- grouped_means / DelayedArray::rowSums(grouped_means)
return(list(mean_exp=grouped_means,
specificity=grouped_specificity))
})
length(ctd)
names(ctd) <- level_names
names(ctd)
dir.create("../model_celltype_conservation/processed_data/EWCE/LaManno2020")
saveRDS(ctd,"../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels.RDS")
ctd$Class
ctd$Class_Age
mat1 <- as(ctd[[1]],"sparseMatrix")
mat1 <- as(ctd[[1]]$mean_exp,"sparseMatrix")
mat1
ctd_lvl <- ctd[[lvl]]
ctd_lvl
names(ctd_lvl)
# Realize the DelayedMatrices as sparseMatrices
ctd_sparse <- ctd
for(lvl in names(ctd_sparse)){
printer(lvl)
ctd_lvl <- ctd_sparse[[lvl]]
for(metric in names(ctd_lvl)){
printer("+",metrix)
ctd_lvl[[metric]] <- as(ctd_lvl[[metric]], "sparseMatrix")
}
ctd_sparse[[lvl]] <- ctd_lvl
}
# Realize the DelayedMatrices as sparseMatrices
ctd_sparse <- ctd
for(lvl in names(ctd_sparse)){
printer(lvl)
ctd_lvl <- ctd_sparse[[lvl]]
for(metric in names(ctd_lvl)){
printer("+",metric)
ctd_lvl[[metric]] <- as(ctd_lvl[[metric]], "sparseMatrix")
}
ctd_sparse[[lvl]] <- ctd_lvl
}
saveRDS(ctd,"../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels_sparse.RDS")
saveRDS(ctd_sparse,"../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels_sparse.RDS")
ctd_sparse[[1]]$mean_exp
ctd_sparse[[1]]$specificity
sce
ctd_sparse[[4]]$specificity
# Realize the DelayedMatrices as sparseMatrices
ctd_sparse <- ctd
for(lvl in names(ctd_sparse)){
printer(lvl)
ctd_lvl <- ctd_sparse[[lvl]]
for(metric in names(ctd_lvl)){
printer("+",metric)
ctd_lvl[[metric]] <- as(as(ctd_lvl[[metric]], "sparseMatrix"),"DelayedMatrix")
}
ctd_sparse[[lvl]] <- ctd_lvl
}
# Realize the DelayedMatrices as sparseMatrices
ctd_sparse <- ctd
for(lvl in names(ctd_sparse)){
printer(lvl)
ctd_lvl <- ctd_sparse[[lvl]]
for(metric in names(ctd_lvl)){
printer("+",metric)
ctd_lvl[[metric]] <- as(as(ctd_lvl[[metric]], "sparseMatrix"),"DelayedArray")
}
ctd_sparse[[lvl]] <- ctd_lvl
}
# Realize the DelayedMatrices as sparseMatrices
ctd_sparse <- ctd
for(lvl in names(ctd_sparse)){
printer(lvl)
ctd_lvl <- ctd_sparse[[lvl]]
for(metric in names(ctd_lvl)){
printer("+",metric)
ctd_lvl[[metric]] <- DelayedArray::DelayedArray(as(ctd_lvl[[metric]], "sparseMatrix"))
}
ctd_sparse[[lvl]] <- ctd_lvl
}
saveRDS(ctd_sparse,"../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels_sparseDA.RDS")
ctd$Class$mean_exp
DelayedArray::seed(ctd$Class$mean_exp)
ctd_sparse$Class$mean_exp
ctd$Class$mean_exp
#### Quantile normalization ####
# Use the rank norm transformation on specificity
rNorm <- function(ctdIN){   bbb = t(apply(ctdIN$specificity,1,RNOmni::rankNorm));  return(bbb)    }
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' \code{bin.specificity.into.quantiles} is an internal function used to convert add '$specificity_quantiles' to a ctd
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A ctd with $specificity_quantiles
#' @examples
#' data(ctd)
#' ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' print(ctd[[1]]$specificity_quantiles[1:3,])
#' @export
bin.specificity.into.quantiles <- function(ctdIN,numberOfBins){
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
rownames(ctdIN$specificity_quantiles) = rownames(ctdIN$specificity)
return(ctdIN)
}
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' \code{bin.specificity.into.quantiles} is an internal function used to convert add '$specificity_quantiles' to a ctd
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A ctd with $specificity_quantiles
#' @examples
#' data(ctd)
#' ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' print(ctd[[1]]$specificity_quantiles[1:3,])
#' @export
bin.specificity.into.quantiles <- function(ctdIN,numberOfBins){
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
rownames(ctdIN$specificity_quantiles) = rownames(ctdIN$specificity)
return(ctdIN)
}
bin.specificity.into.quantiles
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#'
#' @param matrixIn The matrix of specificity values
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A matrix with same shape as matrixIn but with columns storing quantiles instead of specificity
#' @examples
#' data(ctd)
#' ctd[[1]]$specificity_quantiles = apply(ctd[[1]]$specificity,2,
#'                                        FUN=bin.columns.into.quantiles,
#'                                        numberOfBins=40)
#' @export
bin.columns.into.quantiles <- function(matrixIn,numberOfBins=40){
quantileValues = rep(0,length(matrixIn))
quantileValues[matrixIn>0] = as.numeric(cut(matrixIn[matrixIn>0],
breaks=unique(quantile(matrixIn[matrixIn>0], probs=seq(0,1, by=1/numberOfBins), na.rm=TRUE)),
include.lowest=TRUE))
return(quantileValues)
}
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
matrixIn<- ctd$Class$specificity
quantileValues = rep(0,length(matrixIn))
quantileValues[matrixIn>0] = as.numeric(cut(matrixIn[matrixIn>0],
breaks=unique(quantile(matrixIn[matrixIn>0], probs=seq(0,1, by=1/numberOfBins), na.rm=TRUE)),
include.lowest=TRUE))
numberOfBins=40
quantileValues[matrixIn>0] = as.numeric(cut(matrixIn[matrixIn>0],
breaks=unique(quantile(matrixIn[matrixIn>0], probs=seq(0,1, by=1/numberOfBins), na.rm=TRUE)),
include.lowest=TRUE))
quantileValues
max(quantileValues)
#'
#' @param matrixIn The matrix of specificity values
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A matrix with same shape as matrixIn but with columns storing quantiles instead of specificity
#' @examples
#' data(ctd)
#' ctd[[1]]$specificity_quantiles = apply(ctd[[1]]$specificity,2,
#'                                        FUN=bin.columns.into.quantiles,
#'                                        numberOfBins=40)
#' @export
bin.columns.into.quantiles <- function(matrixIn,
numberOfBins=40){
quantileValues = rep(0,length(matrixIn))
quantileValues[matrixIn>0] = as.numeric(
cut(matrixIn[matrixIn>0],
breaks=unique(quantile(matrixIn[matrixIn>0], probs=seq(0,1, by=1/numberOfBins), na.rm=TRUE)),
include.lowest=TRUE)
)
return(quantileValues)
}
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
ctdIN=ctd[[1]]
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
bin.columns.into.quantiles
numberOfBins
ctdIN$specificity
colSums2(is.na(ctdIN$specificity))
ctdIN=ctd_sparse[[1]]
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
ctdIN
#' \code{bin.specificity.into.quantiles} is an internal function used to convert add '$specificity_quantiles' to a ctd
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A ctd with $specificity_quantiles
#' @examples
#' data(ctd)
#' ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' print(ctd[[1]]$specificity_quantiles[1:3,])
#' @export
bin.specificity.into.quantiles <- function(ctdIN,numberOfBins){
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
rownames(ctdIN$specificity_quantiles) = rownames(ctdIN$specificity)
return(ctdIN)
}
ctd_DM <- ctd
ctd <- ctd_sparse
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
ctd = lapply(ctd,prep.dendro)
#'
#' \code{prep.dendro} adds a dendrogram to a cts
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @return A ctd with dendrogram plotting info added
#' @examples
#' ctd = lapply(ctd,EWCE::bin.specificity.into.quantiles,numberOfBins=40)
#' ctd = lapply(ctd,EWCE::prep.dendro)
#' @export
#' @import ggdendro
prep.dendro <- function(ctdIN){
binned_file_dist <- dist(t(ctdIN$specificity_quantiles)) # euclidean distances between the rows
binned_file_dist_hclust <- hclust(binned_file_dist)
ddata <- ggdendro::dendro_data(binned_file_dist_hclust, type="rectangle")
ordered_cells <- as.character(ddata$labels$label)
a1 <- ggplot(segment(ddata)) + geom_segment(aes_string(x="x", y="y", xend="xend", yend="yend")) + coord_flip() +  theme_dendro()
a1 <- a1 + scale_x_continuous(expand = c(0, 1.3))
b1 <- ggplot(segment(ddata)) + geom_segment(aes_string(x="x", y="y", xend="xend", yend="yend")) + theme_dendro()
b1 <- b1 + scale_x_continuous(expand = c(0, 1.3))
ctdIN$plotting = list()
ctdIN$plotting$ggdendro_vertical = a1
ctdIN$plotting$ggdendro_horizontal = b1
ctdIN$plotting$cell_ordering = ordered_cells
return(ctdIN)
}
ctd = lapply(ctd,prep.dendro)
library(ggplot2)
ctd = lapply(ctd,prep.dendro)
#'
#' \code{prep.dendro} adds a dendrogram to a cts
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @return A ctd with dendrogram plotting info added
#' @examples
#' ctd = lapply(ctd,EWCE::bin.specificity.into.quantiles,numberOfBins=40)
#' ctd = lapply(ctd,EWCE::prep.dendro)
#' @export
#' @import ggdendro
prep.dendro <- function(ctdIN){
binned_file_dist <- stats::dist(t(ctdIN$specificity_quantiles)) # euclidean distances between the rows
binned_file_dist_hclust <- stats::hclust(binned_file_dist)
ddata <- ggdendro::dendro_data(binned_file_dist_hclust, type="rectangle")
ordered_cells <- as.character(ddata$labels$label)
a1 <- ggplot2::ggplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggplot2::coord_flip() +  ggdendro::theme_dendro()
a1 <- a1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
b1 <- gggplot2::gplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggdendro::theme_dendro()
b1 <- b1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
ctdIN$plotting = list()
ctdIN$plotting$ggdendro_vertical = a1
ctdIN$plotting$ggdendro_horizontal = b1
ctdIN$plotting$cell_ordering = ordered_cells
return(ctdIN)
}
ctd = lapply(ctd,prep.dendro)
#'
#' \code{prep.dendro} adds a dendrogram to a cts
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @return A ctd with dendrogram plotting info added
#' @examples
#' ctd = lapply(ctd,EWCE::bin.specificity.into.quantiles,numberOfBins=40)
#' ctd = lapply(ctd,EWCE::prep.dendro)
#' @export
#' @import ggdendro
prep.dendro <- function(ctdIN){
binned_file_dist <- stats::dist(t(ctdIN$specificity_quantiles)) # euclidean distances between the rows
binned_file_dist_hclust <- stats::hclust(binned_file_dist)
ddata <- ggdendro::dendro_data(binned_file_dist_hclust, type="rectangle")
ordered_cells <- as.character(ddata$labels$label)
a1 <- ggplot2::ggplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggplot2::coord_flip() +  ggdendro::theme_dendro()
a1 <- a1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
b1 <- ggplot2::gplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggdendro::theme_dendro()
b1 <- b1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
ctdIN$plotting = list()
ctdIN$plotting$ggdendro_vertical = a1
ctdIN$plotting$ggdendro_horizontal = b1
ctdIN$plotting$cell_ordering = ordered_cells
return(ctdIN)
}
ctd = lapply(ctd,prep.dendro)
#'
#' \code{prep.dendro} adds a dendrogram to a cts
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @return A ctd with dendrogram plotting info added
#' @examples
#' ctd = lapply(ctd,EWCE::bin.specificity.into.quantiles,numberOfBins=40)
#' ctd = lapply(ctd,EWCE::prep.dendro)
#' @export
#' @import ggdendro
prep.dendro <- function(ctdIN){
binned_file_dist <- stats::dist(t(ctdIN$specificity_quantiles)) # euclidean distances between the rows
binned_file_dist_hclust <- stats::hclust(binned_file_dist)
ddata <- ggdendro::dendro_data(binned_file_dist_hclust, type="rectangle")
ordered_cells <- as.character(ddata$labels$label)
a1 <- ggplot2::ggplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggplot2::coord_flip() +  ggdendro::theme_dendro()
a1 <- a1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
b1 <- ggplot2::ggplot(ggdendro::segment(ddata)) + ggplot2::geom_segment(ggplot2::aes_string(x="x", y="y", xend="xend", yend="yend")) + ggdendro::theme_dendro()
b1 <- b1 + ggplot2::scale_x_continuous(expand = c(0, 1.3))
ctdIN$plotting = list()
ctdIN$plotting$ggdendro_vertical = a1
ctdIN$plotting$ggdendro_horizontal = b1
ctdIN$plotting$cell_ordering = ordered_cells
return(ctdIN)
}
ctd = lapply(ctd,prep.dendro)
printer("Computing specificity quantiles",paste0("(",numberOfBins,"bins)" ),"...",v=verbose)
printer("Computing specificity quantiles",paste0("(",numberOfBins," bins)" ),"...",v=verbose)
#' \code{bin.specificity.into.quantiles} is an internal function used to convert add '$specificity_quantiles' to a ctd
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A ctd with $specificity_quantiles
#' @examples
#' data(ctd)
#' ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' print(ctd[[1]]$specificity_quantiles[1:3,])
#' @export
bin.specificity.into.quantiles <- function(ctdIN,numberOfBins,
verbose=T){
printer("Computing specificity quantiles",paste0("(",numberOfBins," bins)" ),"...",v=verbose)
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
rownames(ctdIN$specificity_quantiles) = rownames(ctdIN$specificity)
return(ctdIN)
}
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd, bin.specificity.into.quantiles, numberOfBins=numberOfBins)
ctd = lapply(ctd, prep.dendro)
ctd$Class$specificity_quantiles
#' \code{bin.specificity.into.quantiles} is an internal function used to convert add '$specificity_quantiles' to a ctd
#'
#' @param ctdIN A single annotLevel of a ctd, i.e. ctd[[1]] (the function is intended to be used via apply)
#' @param numberOfBins Number of quantile 'bins' to use (40 is recommended)
#' @return A ctd with $specificity_quantiles
#' @examples
#' data(ctd)
#' ctd = lapply(ctd,bin.specificity.into.quantiles,numberOfBins=40)
#' print(ctd[[1]]$specificity_quantiles[1:3,])
#' @export
bin.specificity.into.quantiles <- function(ctdIN,numberOfBins,
as_sparse_DelayedMatrix=T,
verbose=T){
printer("Computing specificity quantiles",paste0("(",numberOfBins," bins)" ),"...",v=verbose)
ctdIN$specificity_quantiles = apply(ctdIN$specificity,2,FUN=bin.columns.into.quantiles,numberOfBins=numberOfBins)
rownames(ctdIN$specificity_quantiles) = rownames(ctdIN$specificity)
if(as_sparse_DelayedMatrix){
ctdIN$specificity_quantiles <- DelayedArray::DelayedArray(as(ctdIN$specificity_quantiles,"sparseMatrix"))
}
return(ctdIN)
}
# ADD DENDROGRAM DATA TO CTD
ctd = lapply(ctd, bin.specificity.into.quantiles, numberOfBins=numberOfBins)
ctd$Class$specificity_quantiles
saveRDS(ctd, "../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels_sparseDM_quant.RDS")
saveRDS(ctd, "../model_celltype_conservation/processed_data/EWCE/LaManno2020/ctd_LaManno2020_4levels_sparseDM_quantDendro.RDS")
ctd$Class_Tissue_Age$plotting
getwd()
devtools::build()
